---
título: "Lección 3: Soluciones de modificación"
archivo de salida: html_document
---

## Soluciones de modificación de datos
Este documento contiene las soluciones de la actividad de modificación. Puedes usar estas soluciones para controlar tu trabajo y asegurarte de que tu código sea correcto o resolver problemas en tu código si marca errores. Si aún no completaste la actividad, te sugerimos que regreses y la termines antes de leer las soluciones.

Si tienes errores, recuerda que puedes buscar ayuda en Internet y en la comunidad de RStudio:
https://community.rstudio.com/#

## Paso 1: Cargar paquetes

Comienza instalando los paquetes requeridos. Si ya instalaste y cargaste `tidyverse`, skimr` y `janitor` en esta sesión, puedes saltearte los bloques de código en este paso.

```{r install packages}
install.packages("tidyverse")
install.packages("skimr")
install.packages("janitor")
```

Una vez que un paquete está instalado, puedes cargarlo ejecutando la función `library()` con el nombre del paquete dentro de los paréntesis:

```{r load packages}
library(tidyverse)
library(skimr)
library(janitor)
```

## Paso 2: Importar datos

Los datos de este ejemplo provienen originalmente del artículo Hotel Booking Demand Datasets (https://www.sciencedirect.com/science/article/pii/S2352340918315191), escrito por Nuno Antonio, Ana Almeida y Luis Nunes para Data in Brief, Volumen 22, febrero de 2019.

Los datos fueron descargados y limpiados por Thomas Mock y Antoine Bichat para #TidyTuesday durante la semana del 11 de febrero de 2020 (https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-02-11/readme.md).

Puedes aprender más sobre este conjunto de datos aquí:
https://www.kaggle.com/jessemostipak/hotel-booking-demand

En el bloque que aparece a continuación, usarás la función `read_csv()` para importar datos de un archivo .csv llamado "hotel_bookings.csv" en la carpeta del proyecto y guardarlo como un marco de datos llamado `hotel_bookings`:

```{r load dataset}
hotel_bookings <- read_csv("hotel_bookings.csv")
```

## Paso 3: Conocer tus datos

Como has hecho en otros ejemplos, usa la función `head()` para tener una vista previa de las columnas y las primeras filas de datos ejecutando el bloque que aparece debajo:

```{r head function}
head(hotel_bookings)
```
## Respuestas del cuestionario de práctica 

1. ¿Cuántas columnas hay en este conjunto de datos?
A: 45
B: 100
C: 32
D: 60
Respuesta: C: Hay 32 columnas en este conjunto de datos. La función `head()` devuelve una vista previa del conjunto de datos, incluyendo las seis primeras filas de datos y todas las columnas que entren en la pantalla. En la esquina inferior izquierda de la tabla, indica que es la vista previa de 1-4 de 32 columnas. 

2. La variable 'arrival_date_month' es un dato de tipo chr o código de carácter.  
A: Verdadero
B: Falso
Respuesta: A. La variable 'arrival_date_month' es un dato de tipo chr o código de carácter. Debajo del nombre de la columna en la tabla de vista previa, hay una descripción del tipo de dato para cada columna. 

Además de `head()`, también puedes usar las funciones `str()` y `glimpse()` para obtener resúmenes de cada columna en tus datos organizados horizontalmente. Puedes probar estas dos funciones ejecutando los bloques de código que aparecen a continuación:

```{r str function}
str(hotel_bookings)
```

Puedes ver los diferentes nombres de columna y algunos valores de muestra a la derecha de los dos puntos. 

```{r glimpse function}
glimpse(hotel_bookings)
```

También puedes usar `colnames()` para obtener los nombres de las columnas en tu conjunto de datos. Ejecuta el bloque de código que aparece debajo para obtener los nombres de las columnas:

```{r colnames function}
colnames(hotel_bookings)
```

## Manipular tus datos

Digamos que quieres ordenar los datos de mayor tiempo de antelación a menor tiempo de antelación porque quieres enfocarte en reservas que se realizaron con mucha anticipación. Decides que quieres intentar usar la función `arrange()` y ejecutas el siguiente comando: 

```{r arrange function}
arrange(hotel_bookings, lead_time)
```

`arrange()` organiza automáticamente en orden ascendente y debes indicarle específicamente cuándo organizar en orden descendente, como el bloque de código que aparece a continuación:

```{r arrange function descending} 
arrange(hotel_bookings, desc(lead_time))
```
## Respuestas del cuestionario de práctica

¿Cuál es el mayor tiempo de antelación para una reserva de hotel en este conjunto de datos?
A: 737
B: 709
C: 629
D: 0

Respuesta: A. El mayor tiempo de antelación para una reserva de hotel en este conjunto de datos es 737 días. Después de usar la función arrange() para ordenar las reservas de hotel (hotel_bookings) por tiempo de antelación en orden descendente, observarás que 737 es la primera fila. ¡Eso es más de dos años de antelación!

Observa que cuando solo ejecutas `arrange()` sin guardar tus datos en un nuevo marco de datos, no modifica el marco de datos existente. Comprueba ejecutando de nuevo `head()` para ver si los mayores tiempos de antelación están primero: 

```{r head function part two}
head(hotel_bookings)
```

Si quisieras crear un nuevo marco de datos que tuviera guardados estos cambios, usarías <- , tal como está escrito en el bloque de código debajo, para almacenar los datos ordenados en un marco de datos llamado 'hotel_bookings_v2'

```{r new dataframe}
hotel_bookings_v2 <-
  arrange(hotel_bookings, desc(lead_time))
```

Observa el nuevo marco de datos: 

```{r new dataframe part two}
head(hotel_bookings_v2)
```

También puedes averiguar los tiempos máximos y mínimos de antelación sin ordenar todo el conjunto de datos usando la función `arrange()`. Prueba usando las funciones max() y min() debajo:

```{r}
max(hotel_bookings$lead_time)
```

```{r}
min(hotel_bookings$lead_time)
```

Recuerda que, en este caso, necesitas especificar qué conjunto de datos y qué columna usando el símbolo $ entre los nombres. Prueba ejecutar lo siguiente para ver qué pasa si te olvidas una de esas partes:

```{r}
min(lead_time)
```

Este es un error común que encuentran los usuarios de R. 

Ahora, digamos que solo quieres saber el tiempo de antelación promedio de las reservas porque tu jefe te pregunta con cuánta anticipación deberías realizar las promociones de habitaciones de hotel. Puedes usar la función `mean()`para responder esa pregunta:

```{r mean}
mean(hotel_bookings$lead_time)
```

Deberías obtener la misma respuesta aun si usas el conjunto de datos v2 que incluyó la función `arrange()`. 

```{r mean part two}
mean(hotel_bookings_v2$lead_time)
```

## Cuestionario de práctica 

¿Cuál es el tiempo promedio de antelación?
A: 100
B: 45
C: 14
D: 104.0114

Respuesta: D. El tiempo promedio de antelación es de 104.0114 días. Pudiste calcularlo usando la función mean() en la columna lead_time de tu conjunto de datos. 

Le pudiste informar a tu jefe cuál es el tiempo promedio de antelación de las reservas, pero ahora quiere saber cuál es el tiempo promedio de antelación de las reservas solamente de los hoteles urbanos. Quieren enfocar la promoción que están realizando, dirigiéndola a grandes ciudades.

Tú sabes que el primer paso será crear un nuevo conjunto de datos que solo contenga datos sobre hoteles urbanos. Puedes hacerlo usando la función `filter()` y nombrar a tu nuevo marco de datos 'hotel_bookings_city':

```{r filter}
hotel_bookings_city <- 
  filter(hotel_bookings, hotel_bookings$hotel=="City Hotel")
```

Mira tu nuevo conjunto de datos:

```{r new dataset}
head(hotel_bookings_city)
```

Puedes consultar con rapidez cuál es el tiempo de antelación promedio para este conjunto de hoteles, tal como lo hiciste con todos los hoteles antes:

```{r average lead time city hotels}
mean(hotel_bookings_city$lead_time)
```

Ahora, tu jefe quiere obtener mucha más información sobre hoteles urbanos, incluyendo tiempo máximo y mínimo de antelación de las reservas. También le interesa en qué difieren a los hoteles tipo resort. No quieres ejecutar cada línea de código una y otra vez, por lo que decides usar las funciones `group_by()`y `summarize()`. También puedes usar el operador de canalización para que tu código sea más fácil de seguir. Almacenarás el nuevo conjunto de datos en un marco de datos llamado 'hotel_summary':

```{r group and summarize}
hotel_summary <- 
  hotel_bookings %>%
  group_by(hotel) %>%
  summarise(average_lead_time=mean(lead_time),
            min_lead_time=min(lead_time),
            max_lead_time=max(lead_time))
```

Comprueba tu nuevo conjunto de datos usando head() nuevamente:

```{r}
head(hotel_summary)
```
